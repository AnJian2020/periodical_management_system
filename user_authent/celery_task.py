# -*- coding: utf-8 -*- 
# Generated by xuhao on 2020/11/18 11:23

import json
import random
import os
from celery import shared_task
from periodical_management_system.settings import KEY_VALUE_OUT_TIME
from django.contrib.auth.models import User, Group
from django.forms import model_to_dict
from django.db.models import Q
from .models import UserInformation, UserMenuModel, GroupMenuShip
from .modelSerializer import UserInformationModelSerializer,UserMenuModelSerialzier
from django_redis import get_redis_connection

redis_connection = get_redis_connection()


@shared_task
def userRegister(username, password, email):
    user = User.objects.filter(username=username)
    if user:
        return False
    if not User.objects.create_user(username=username, password=password, email=email):
        return False
    return True


@shared_task
def sendIdentityCode(username):
    user = User.objects.filter(username=username).first()
    if user and user.email:
        code = chr(random.randint(65, 91)) + str(random.randint(1000, 9999))
        redis_connection.setex(username + ":identity", 60 * 60, code)
        with open(os.path.join(os.getcwd(), 'user_authent', 'settings.json'), 'r', encoding='utf-8') as f:
            context = json.load(f)['context'] % code
        user.email_user("PERIODICAL MANAGEMENT SYSTEM", context)
        return json.dumps({'result': 'success', 'message': "用户验证码发送成功"})
    else:
        return json.dumps({'result': 'fail', 'message': "用户不存在或者用户未完善联系方式"})


@shared_task
def selectUserInformation(username):
    # 先从redis中查询该用户的个人信息是否存在，如果不存在，则在数据库中查询。并且将查询结果存储到redis中
    selectUserInformationFromRedis = redis_connection.hgetall(username + ":information")
    if selectUserInformationFromRedis:
        selectUserInformationFromRedis = {k.decode('utf-8'): v.decode('utf-8') for k, v in
                                          selectUserInformationFromRedis.items()}
        return json.dumps(selectUserInformationFromRedis)
    else:
        userInformation = model_to_dict(UserInformation.objects.filter(username=username).first())
        for key in userInformation.keys():
            if (not isinstance(userInformation[key], (str, bytes, int, float)) and userInformation[key]) or isinstance(
                    userInformation[key], bool):
                userInformation[key] = str(userInformation[key])
            if not userInformation[key]:
                userInformation[key] = 'None'
        if userInformation:
            redis_connection.hset(username + ":information", mapping=dict(userInformation))
            redis_connection.expire(username + ":information", KEY_VALUE_OUT_TIME)
            return json.dumps(userInformation)
            # return json.dumps(userInformation,
            #                   default=lambda obj:str(obj.year)+'-'+str(obj.month)+'-'+str(obj.day) if isinstance(obj,date) else obj.__dict__)
        else:
            return json.dumps({"result": 'fail', "message": "用户未完善个人信息。"})


@shared_task
def modifyUserInformation(username, **kwargs):
    """
    修改用户的个人信息，并且将修改过后的个人信息存储到redis中
    :param username:
    :param kwargs:
    :return:
    """
    user = UserInformation.objects.filter(username=username).first()
    serializer = UserInformationModelSerializer()
    if user:
        try:
            serializer.update(user, kwargs)
            redis_connection.hset(username + ":information", mapping=dict(kwargs))
            return json.dumps({"result": "success", 'message': '信息更新成功！'})
        except Exception as error:
            return json.dumps({"result": 'fail', 'message': '信息更新失败！', "error": error})
    return json.dumps({'result': 'fail', 'message': '用户不存在！'})


@shared_task
def createUserInformation(username, **kwargs):
    """
    创建用户个人信息，并将信息存储到redis中
    :param username:
    :param kwargs:
    :return:
    """
    operation = UserInformation.objects.filter(username=username).first()
    if not operation:
        kwargs['username'] = username
        serializer = UserInformationModelSerializer(data=kwargs)
        if serializer.is_valid():
            serializer.save()
            redis_connection.hset(username + ':information', mapping=kwargs)
            redis_connection.expire(username + ":information", KEY_VALUE_OUT_TIME)
            return json.dumps({"result": "success", 'message': '用户信息创建成功！'})
        return json.dumps({'result': 'fail', 'message': serializer.errors})
    return json.dumps({'result': 'fail', 'message': '用户信息已存在，无需重复创建！'})


@shared_task
def getUserMenuTask(user, username):
    """
    获取系统用户菜单，先从缓存中查询是否存在，如果不存在，则直接查询数据库，将查询结果存储到数据库和缓存中。
    :param user:
    :param username:
    :return: menuList
    """
    redisUserGroup = redis_connection.get(username + ":group")
    if redisUserGroup:
        redisGroupMenu = redis_connection.get(redisUserGroup.decode() + ":menu")
        if redisGroupMenu:
            return redisGroupMenu.decode()
    userGroup = Group.objects.get(user=user)
    menu = UserMenuModel.objects.filter(menu_role=userGroup.id)
    menuList = list()
    for item in menu:
        if item.parent_menu is None:
            menuList.append(dict(id=item.id, menu_name=item.menu_name, menu_level=item.menu_level, child_menu=[]))
    for item in menu:
        if item.parent_menu:
            for firstMenu in menuList:
                if item.parent_menu.id == firstMenu['id']:
                    firstMenu['child_menu'].append(
                        dict(id=item.id, menu_name=item.menu_name, menu_level=item.menu_level, child_menu=[]))
    redis_connection.setex(userGroup.name + ":menu", 60 * 60, json.dumps(menuList))
    redis_connection.setex(username + ":group", 60 * 60, userGroup.name)
    return json.dumps(menuList)


@shared_task
def createUserMenuTask(**menuData):
    """
    创建用户菜单
    :param menuData:
    :return:
    """
    MENU = ('menu_name', 'menu_level', 'parent_menu', 'menu_path', 'menu_role')
    for item in menuData:
        if item not in MENU:
            return json.dumps({'result': 'fail', 'message': '提交的数据项不全！'})
    operation = UserMenuModel.objects.filter(menu_name=menuData['menu_name']).first()
    # if not operation:
    #     serializer = UserMenuModelSerialzier(data=menuData)
    #     if serializer.is_valid():
    #     #     serializer.save()
    #         # for group in menuData['menu_role']:
    #         #     groupName=Group.objects.filter(id=group).first().name
    #         #     redis_connection.delete(groupName+':menu')
    #         return json.dumps({'result': 'success', 'message': '用户菜单添加成功！'})
    #     return json.dumps({'result': 'fail', 'message': serializer.errors})
    # return json.dumps({"result": 'fail', 'message': '该用户菜单已经存在，无需重复添加！'})
    if not operation:
        try:
            menu_role = menuData.pop('menu_role')
            if menuData.get('parent_menu'):
                menuData['parent_menu'] = UserMenuModel.objects.filter(id=menuData['parent_menu']).first()
            menu = UserMenuModel.objects.create(**menuData)
            group = Group.objects.filter(id=menu_role).first()
            group_menu = GroupMenuShip(group_id_id=group.id, menu_id_id=menu.id)
            group_menu.save()
            redis_connection.delete(group.name + ':menu')
            return json.dumps({'result': 'success', 'message': '用户菜单添加成功！'})
        except Exception as error:
            raise Exception(error)
            return json.dumps({"result": 'fail', 'message': 'error'})
    return json.dumps({"result": 'fail', 'message': '该用户菜单已经存在，无需重复添加！'})


@shared_task
def deleteUserMenuTask(options,delete_menu_role):
    """
    :param options:
    :param delete_menu_role: 删除的菜单所属用户组的组名
    :return:
    """
    if isinstance(options, (int, str)):
        menu = UserMenuModel.objects.filter(Q(id=options) | Q(menu_name=options))
        if not menu:
            return json.dumps({'status': 204, "data": str(options) + "删除失败！失败原因：选择的删除项不存在。"})
        menu.delete()
        redis_connection.delete(delete_menu_role + ':menu')
        return json.dumps({'status': 200, "data": str(options) + "删除成功！"})
    return json.dumps({"status": 204, 'data': str(options) + "删除失败！失败原因：选择的删除项不正确。"})


@shared_task
def modifyUserMenuTask(**new_menu_data):
    """
    :param new_menu_data:
    :return:
    """
    MENU = ('menu_name', 'menu_level', 'parent_menu', 'menu_path', 'modify_menu_role')
    for item in MENU:
        if item not in new_menu_data.keys():
            return json.dumps({"status":204,'data':'提交的数据项不全！'})
    menuId=new_menu_data.get('id')
    menu=UserMenuModel.objects.filter(id=menuId).first()
    if menu:
        parent_menu_id=new_menu_data.get('parent_menu')
        modify_menu_role=new_menu_data.pop('modify_menu_role')
        # new_menu_data['parent_menu']=UserMenuModel.objects.filter(id=parent_menu_id).first().id
        parent_menu=UserMenuModel.objects.filter(id=parent_menu_id).first()
        if parent_menu:
            new_menu_data['parent_menu']=parent_menu.id
        else:
            return json.dumps({"status":204,'data':"设置的父菜单不存在"})
        serializer=UserMenuModelSerialzier(data=new_menu_data)
        if serializer.is_valid():
            serializer.update(menu,new_menu_data)
            redis_connection.delete(modify_menu_role + ':menu')
            return json.dumps({'status':200,'data':'菜单修改成功。'})
        return json.dumps({'status':204,'data':serializer.errors})
    return json.dumps({'status':204,'data':'该菜单不存在！'})



